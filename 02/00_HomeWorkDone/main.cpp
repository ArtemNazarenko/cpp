//  ЗАДАНИЕ:
// Пользователь вводит натуральное число N.
// Нужно вывести все способы разложить его на слагаемые.
// Способы отличающиеся только
// порядком слагаемых считаются одинаковыми.
//
// Например N = 4:
// 4 = 4
// 4 = 3 + 1
// 4 = 2 + 2
// 4 = 2 + 1 + 1
// 4 = 1 + 1 + 1 + 1
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

int min(int a, int b) {
  return (a <= b) ? a : b;
}

// Массив слагаемых
int A[1000]; // vector<>
// Число для разложения
int N;

// Разложить N на слагаемые
// и вывести ответ
// S - сумма, которую осталось разложить
// last - верхний предел для слагаемого
//   (предыдущее слагаемое)
// i - индекс текущего слагаемого
void f(int S, int last, int i) {
  static int calls = 0;
  calls++;
  //cout << "call " << calls << endl;

  // Вывод ответа
  if(S == 0) {
    cout << N << " = ";
    // Выводим все слагаемые кроме последнего с '+'
    for(int j = 0; j < i - 1; j++)
      cout << A[j] << " + ";
    // А последнее с переводом строки
    cout << A[i - 1] << endl;
    return;
  }

  // x - текущее слагаемое
  // Оно не может быть больше чем оставщаяся сумма
  // и не может быть больше чем предыдущее слагамое
  // И не может быть меньше 1
  for(int x = min(S, last); x >= 1; --x) {
    // Отладочный вывод
    //cout << "A[" << i << "] = " << x << endl;
    A[i] = x; // Сохраняем очередное слагаемое
    // Оставщаяся сумма уменьшается на x
    // Новый верхний предел - x
    // И позиция сдвигается на 1
    f(S - x, x, i + 1);
  }
}

int main() {
  // Пользователь вводит натуральное число N
  //cout << "N = ";
  freopen("decomposition.in", "w", stdin);
  cin >> N;
  //N = 30;
  // Вывод в файл вместо экрана
  // freopen(Имя_файла, режим_работы, перенаправляемый_поток);
  // (чтение "r", запись "w", добавление в конец "a")
  freopen("decomposition.out", "w", stdout);
  // stdin
  // stdout
  // stderr

  // Рекурсивный вызов функции
  f(N, N, 0); // сначала старшее слагаемое до N

  return 0;
}
