\section{ООП - принципы: классы, объекты, прототипы} 

\subsection{Абстракция, класс, объект, прототип}

\begin{frame}[t,fragile]{Объектно-ориентированное программирование}

Способ программирования, в котором используются 
\textbf{объекты}
 и 
\textbf{классы}. 

\textbf{Абстрагирование} --- 
выделение набора важных с точки зрения решаемой задачи характеристик объекта, исключая из рассмотрения неважные. 

\textbf{Абстракция} --- 
набор всех важных характеристик объекта, реализуется в ООП-языках при помощи Класса. 

Пример: решаем задачу с точками на плоскости, для каждой
точки важны её координаты $(x; y)$.

\textbf{Класс} ---
создаваемый программистом новый тип данных,
модель ещё не существующей сущности (объекта).

\begin{lstlisting}
class Point { double x,y; }
\end{lstlisting}

\textbf{Объект} --- 
конкретная <<точка>>, экземпляр класса.

\begin{lstlisting}
Point A = {2.0, 1.5}, B = {-2, 1};
\end{lstlisting}

\textbf{Прототип} ---
объект-образец, по образу и подобию которого создаются другие объекты
путём копирования и изменения различных свойств. 
\end{frame}

\subsection{Инкапсуляция, наследование и полиморфизм}

\begin{frame}[t]{Принципы ООП}

\textbf{Инкапсуляция} (лат. in capsula) --- свойство системы, позволяющее объединить данные и методы, 
работающие с ними, в классе, и скрыть детали реализации от пользователя.

\textbf{Наследование} --- свойство системы, позволяющее описать новый класс на основе 
уже существующего с частично или полностью заимствующейся функциональностью. 
Класс, от которого производится наследование, называется 
\textbf{базовым}, \textbf{родительским} или \textbf{суперклассом}. 
Новый класс --- \textbf{потомком}, \textbf{наследником}, \textbf{дочерним} или \textbf{производным} классом.

\textbf{Полиморфизм} --- свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
При использовании термина <<полиморфизм>> в сообществе ООП подразумевается полиморфизм подтипов; 
а использование параметрического полиморфизма называют обобщённым программированием.

\end{frame}
                     
\subsection{Объявление класса: аттрибуты, поля, методы}
\begin{frame}[t,fragile]{Класс <<Точка>> --- не используя ООП}

Если нам нужно хранить 100 точек, то мы можем создать 2 независимых массива:
\begin{lstlisting}
double x[100], y[100];
\end{lstlisting}

И синхронно их использовать:
\begin{lstlisting}
  x[0] = 1;  y[0] = 2;
\end{lstlisting}

Или создать структуру точка:
\begin{lstlisting}
struct Point {
  double x, y;
};
\end{lstlisting}

Чтобы потом создать массив из точек:
\begin{lstlisting}
Point p[100];
\end{lstlisting}

И обращаться к нему:
\begin{lstlisting}
  p[0].x = 1; p[0].y = 2;
  Point p1; p1.x = 2;
\end{lstlisting}
\end{frame}

\subsection{Объявление и использование класса}
\begin{frame}[t,fragile]{Объявление и использование класса}

Объявление класса <<Point2D>>:
\begin{lstlisting}
class Point2D {
 public:
  double x, y; // Поля (данные) класса
  // Метод класса <<Передвинуть точку>>
  void move(double dx, double dy) { x += dx; y += dy; }
  // Повернуть точку относительно начала координат
  void rotate(double angle) { ... }
};
\end{lstlisting}

Использование класса:
\begin{lstlisting}
  Point2D p[100]; // Массив
  p[10].x = 10.1;  p[10].y = 10.3;
  p[0].move(1, 2);
\end{lstlisting}

\end{frame}

\subsection{Более сложный пример - стек}

\begin{frame}[t,fragile]{Более сложный пример - стек}
\begin{lstlisting}
// Объявление класса
class Stack { // класс ИмяКласса
  // Константы
  const static int STACK_SIZE = 100; // Размер стека
  // private-поля класса
  int data[STACK_SIZE]; // Данные
  int count = 0; // Сколько элементов в стеке сейчас
 public: // public-методы - те, операции которые будем использовать извне
  // Положить данные на вершину стека
  void push(int value) { // тип\_возвр\_значения имя \(аргументы\)
    if(count == STACK_SIZE) { // Стек полон
      cout << "Stack is full!" << endl;
      return;
    }
    data[count++] = value; // Записываем значение и увеличиваем количество
  }
  // Забрать данные с вершины стека
  int pop() {
    if(count == 0) { // Стек пуст
      cout << "Stack is empty!" << endl;
      return -1; // Не можем ничего не вернуть
    }
    return data[--count]; // Уменьшаем количество и возвращаем значение
  }
};
\end{lstlisting}
\end{frame}

\begin{frame}[t,fragile]{Более сложный пример - стек - пример использования}
\begin{lstlisting}
int main(){
  Stack s; // Создание переменной - экземпляра стека
    // Стек пуст
  s.push(2); // Положим в стек число 2
    // Теперь стек: | 2 |
  s.push(3); // а затем число 3
    // Теперь стек: | 3 | 2 |
  cout << "3 - " << s.pop() << endl; // Должно быть 3
    // Теперь стек: | 2 |  
  cout << "2 - " << s.pop() << endl; // Должно быть 2
    // Извлекли все значения - снова пуст 
  return 0;
}
\end{lstlisting}
\end{frame}

 
% * Создание экземпляра 
\subsection{Конструкторы и деструкторы}

\begin{frame}[t,fragile]{Конструкторы и деструкторы}

\textbf{Конструктор} (construct - создавать) --- 
специальный метод класса, который выполняется после создания объекта и предназначен для инициализации 
полей класса некоторыми начальными значениями.

Несколько конструкторов должны отличаться типами передаваемых значений.

\textbf{Деструктор} (destruct - разрушать) --- 
специальный метод класса, который служит для уничтожения 
элементов класса и выполняется перед удалением объекта. 

В классе может быть только один деструктор.

\end{frame}

\subsection{Конструкторы и деструкторы - MyClass}

\begin{frame}[t,fragile]{Конструкторы и деструкторы - пример}
\begin{lstlisting}
class MyClass {
  static int count; // Количество объектов
  int id; // Идентификатор данного объекта
  int* data;
  char* name;
 public:
  // Конструктор - после создания экземпляра (объекта) класса
  MyClass(char*);
  // Деструктор - перед уничтожением экземпляра (объекта)
  ~MyClass();
};
// Инициализация static-переменной
int MyClass::count = 0;

MyClass::MyClass(char* n = "") : name(n), id(++count) {
  cout << "Constructor #" << id << " " << name << endl;
  data = new int[1000]; // Отводим динамическую память
  data[0] = 10; // Используем её как хотим
}
MyClass::~MyClass() {
  cout << "Destructor #" << id << " " << name << endl;
  delete[] data; // Освобождаем динамическую память
}
\end{lstlisting}
\end{frame}

\subsection{Template - шаблоны функций}

\begin{frame}[t,fragile]{Шаблоны функций}

Многие алгоритмы применимы сразу к множеству типов данных 
(пример: алгоритмы <<сортировки>> можно применить к массиву с любым типом элементов если поддерживается операция сравнения). 

Можно написать несколько функций отличающихся только типом значения, но такой набор сложно будет сопровождать.

В C++ можно параметризовать функцию:
\begin{lstlisting}
template <class T> f(params...) {
  // тело функции
} 
\end{lstlisting}
В общем случае шаблон функции может содержать произвольное число параметров:
\begin{lstlisting}
template <class X, class Y, int size> void f(){ ... } 
\end{lstlisting}

\end{frame}

\begin{frame}[t,fragile]{Шаблоны функций - 2}


\end{frame}


% * Конструкторы и деструкторы классов. Возможности инициализации объектов. Копирующий конструктор.
% * Определение и перегрузка операторов класса в C++. Вывод в поток.
% * Прототипы
% * Практика: класс "рациональная дробь"
