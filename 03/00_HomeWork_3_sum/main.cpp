/// Домашнее задание - рекурсия + работа с массивами
/// ------------------------------------------------
///  ЗАДАНИЕ:
/// Пользователь вводит натуральное число N.
/// Нужно вывести все способы разложить его на слагаемые.
/// Способы отличающиеся только
/// порядком слагаемых считаются одинаковыми.
///
/// Например N = 4:
/// 4 = 4
/// 4 = 3 + 1
/// 4 = 2 + 2
/// 4 = 2 + 1 + 1
/// 4 = 1 + 1 + 1 + 1
///
/// N = 5
/// 5 = 5
/// 5 = 4 + 1
/// 5 = 3 + 2
/// 5 = 3 + 1 + 1
/// 5 = 2 + 2 + 1
/// 5 = 2 + 1 + 1 + 1
/// 5 = 1 + 1 + 1 + 1 + 1

#include <iostream>
#include <cmath>

//-->
// Макрос вычисления минимума в чистом C
#define MIN(x,y) (x < y) ? x : y

// Функция для вычисления минимума двух целых чисел
int min2(int x, int y) {
  return (x < y) ? x : y;
}

// Шаблонная функция
template <class T>
T min3(T x, T y) {
  return (x < y) ? x : y;
}
//<--

#ifdef DEBUG
#define SHOW(x)  cout << #x << " = " << x << endl;
#else
#define SHOW(x)
#endif // DEBUG

using namespace std;

const int MAX_N = 10000;

int N; // Исходное число для разложения

/// S - осталось для разложения (сумма)
/// m - максимальное слагаемое в сумме
///   все последующие слагаемые должны быть меньше или равны
/// K - количество слагаемых (сколько слагаемых сейчас в сумме)
void sum(int S, int m, int K) {
  // Массив для хранения цифр
  static int A[MAX_N];

  // Окончание рекурсии - выводим сумму
  if(S == 0) {
    cout << N << " = " << A[0];

    for(int i = 1; i < K; ++i)
      cout << " + " << A[i];

    cout << endl;
    return;
  }

  SHOW(S);
  SHOW(m);
  SHOW(K);

  // Если сумма не 0
  for(int x = min(S, m); x >= 1; --x) {
    SHOW(x);
    // x - текущее слагаемое
    A[K] = x;
    // Сумма уменьшилась на x
    // Максимальное слагаемое - x
    sum(S - x, x, K + 1); // Рекурсия
  }
}

int main() {
  // Вводим число N
  cout << "N = ";
  cin >> N;
  // Вызываем функцию разложения на слагаемые
  sum(N, N, 0);
  return 0;
}
